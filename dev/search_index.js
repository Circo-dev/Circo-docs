var documenterSearchIndex = {"docs":
[{"location":"infotons/#Infoton-Optimization","page":"Infoton Optimization","title":"Infoton Optimization","text":"","category":"section"},{"location":"infotons/#Introduction","page":"Infoton Optimization","title":"Introduction","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"An old issue of distributed systems comes from the layered cost and latency structure of communication: Networks are slow and bandwidth-limited, whereas inter-thread communication is much faster, but still slow compared to in-thread data passing. Thus communication is often the performance bottleneck that limits scalability and needs to be optimized.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"Infoton optimization tries to minimize communication by using a physics-inspired model. It is essentially a decentralized, scalable version of force-directed graph drawing, aka \"spring layout\" [1].","category":"page"},{"location":"infotons/#Description","page":"Infoton Optimization","title":"Description","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"Infoton optimization is executed in a \"3D Euclidean\" space, where actors[2] and schedulers (threads that execute actor code) are embedded. The central idea is that actors move close to their communication partners in the Euclidean space, while distance between them approximates communication costs. This way the communication cost is minimized.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"To approximate communication overhead with actor distance:","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"Schedulers are also embedded in the space, in a way that their distance represents communication overhead between them. This can be done either by static positioning or the use of network coordinates.\nActors are migrated to the nearest scheduler.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"To move communicating actors close to each other:","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"A so-called infoton, a force-carrying particle is attached to every message passed between actors. It is a small structure that holds the position of the source actor and a scalar \"energy\".\nWhen the message arrives at its destination actor, the infoton that is attached to it acts on that actor, pulling it towards the source of the message.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"This would result in all the actors concentrating around a single point, so we need at least one another force to spread the actors in the segment of the space which is \"covered\" with schedulers. For this:","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"When a message arrives, the scheduler that executes the target actor creates a second infoton. The source of this infoton is the scheduler itself.\nThis infoton either pulls or pushes the actor toward or away from the scheduler, depending on the \"load\" of the scheduler. The pulling/pushing behavior of the infoton is called its sign, and it is implemented as the sign of its energy field.","category":"page"},{"location":"infotons/#Sample-images","page":"Infoton Optimization","title":"Sample images","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"infotons/#Notes","page":"Infoton Optimization","title":"Notes","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"The limits and applicability of this algorithm is not yet explored, implementation details are not fixed. Quoted terms in the description mark areas of uncertainty.\nThe cost of this optimization is a small, constant overhead on every message sent, plus the overhead of actor migration. Actor count is irrelevant, as inactive actors are not optimized.\nActors cannot collide in this model. They may be positioned at the exact same place.\nHowever, infotons attached to messages also can have a negative sign to push away the destination actor instead of pulling it. This can be used to introduce domain-specific knowledge or special requirements into the model. E.g. If multiple copies of a piece of data exist in the system for failure tolerance,  the copies can preiodically check the liveness of each other while also spread as a result.","category":"page"},{"location":"infotons/#Sample-codes-(Julia)","page":"Infoton Optimization","title":"Sample codes (Julia)","text":"","category":"section"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"This is the current default implementation in Circo of how an infoton acts on the target actor. In this version pulling forces are not applied if the distance between the source and the target is too small. This trick seems to lead to better results in some cases. It introduces a parameter called TARGET_DISTANCE, and it can be thought of as a rudimentary approximation of a separate force that pushes actors away when they are too close.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"Pos = VecE3{Float32} # 3D coordinates\n\nstruct Infoton\n    sourcepos::Pos\n    energy::Float32 # The sign of this field is called the sign of the Infoton\n    Infoton(sourcepos::Pos, energy::Real = 1) = new(sourcepos, Float32(energy))\nend\n\nconst TARGET_DISTANCE = 15.0\n\nfunction apply_infoton(targetactor::AbstractActor, infoton::Infoton)\n    diff = infoton.sourcepos - targetactor.core.pos\n    difflen = norm(diff)\n    energy = infoton.energy\n    if energy > 0 && difflen < TARGET_DISTANCE\n        return nothing\n    end\n    targetactor.core.pos += diff / difflen * energy\n    return nothing\nend","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"[2]: For simplicity, here I use the actor model to describe the algorithm, but it can be adapted to other concurrency models.","category":"page"},{"location":"infotons/","page":"Infoton Optimization","title":"Infoton Optimization","text":"[1]: Force-directed graph drawing in Wikipedia","category":"page"},{"location":"plugindev/#Plugin-development","page":"Plugin development","title":"Plugin development","text":"","category":"section"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"To get familiar with the plugin system, please read the documentation of Plugins.jl","category":"page"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"For sample code, look for any plugin in the source code. E.g. OnMessage is trivial, MsgStats and Event are a bit more involved.","category":"page"},{"location":"plugindev/#Plugin-Lifecycle","page":"Plugin development","title":"Plugin Lifecycle","text":"","category":"section"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"Following is the list of hooks to implement in plugins. Time goes top → down, except:","category":"page"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"When there is no empty line between hooks, then the call order is not defined.\nIndented blocks may be called repeatedly","category":"page"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"customfield(plugin, parent_type) # Provide extra fields to core types\n\nprepare(plugin, ctx) # Initial stage, plugins can use eval() here\n\n# Execution flow will reach top-level to allow staged code to run\n\nsetup!(plugin, scheduler) # Allocate resources\n\n    schedule_start(plugin, scheduler) # Scheduling may be stopped and restarted several times\n\n        schedule_continue(plugin, scheduler) # Scheduling continues after stop or pause (also called after start)\n\n            localdelivery() # Deliver a message to an actor (e.g. call onmessage)\n            localroutes() # Handle messages that are targeted to actors not (currently) scheduled locally (e.g. during migration).\n            specialmsg() # Handle messages that are targeted to the scheduler (to the box 0)\n            remoteroutes() # Deliver messages to external targets\n            actor_activity_sparse16() # An actor just received a message, called with 1/16 probability\n            actor_activity_sparse256() # An actor just received a message, called with 1/256 probability\n            spawnpos() # Provide initial position of an actor when it is spawned\n\n            letin_remote() # Let external sources push messages into the queue (using deliver!).\n\n        schedule_pause(plugin, scheduler) # Scheduling is paused for a short time, e.g. to optimize code\n\n        stage(plugin, scheduler, stagenum) # Next stage TODO not implemented\n\n    schedule_stop(plugin, scheduler) # Scheduling is stopped for a potentially longer period\n\nshutdown!(plugin, scheduler) # Release resources","category":"page"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"If you need a new hook, please file an issue to discuss your use case and find the best way to implement it!","category":"page"},{"location":"plugindev/","page":"Plugin development","title":"Plugin development","text":"TODO: A real plugin dev guide","category":"page"},{"location":"showcase/#Showcase","page":"Showcase","title":"Showcase","text":"","category":"section"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"When you install & run the system, on http://localhost:8000 soon you will see something like the following:","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"(Image: The sample loaded in Camera Diserta)","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"This is the tool \"Camera Diserta\" monitoring the default example: A linked list of 4000 actors, that - when started - will calculate the sum of the list repeatedly.","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"6 schedulers are available, but initially all the actors are scheduled on the same one. They will migrate to the other schedulers automatically. Actors are placed in a 3D space randomly - 3D isn't just a fancy visualization trick, but an important element of infoton optimization.","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"To try out the example, you have to send a \"Run\" message to the test coordinator:","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"Click \"coordinators\" in the upper left corner to filter only the test coordinator\nClick the coordinator to select it\nThe commands accepted by the coordinator will be queried from it\nClick \"Run\" when it appears\nClick \"all\" to see all the actors again\nWait for the magic to happen\nCheck the logs of the backend to see the speedup","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"After a while Camera Diserta will display something like the following:","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"(Image: Infoton-optimized version of the sample)","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"Large cuboids are the schedulers (size indicates the number of actors they execute), small cubes packed together are list item actors. Actors are scheduled on the scheduler that is closest in the 3D space.","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"As you can see, Circo's infoton optimization found out the structure of the list without using any \"domain\" knowledge, just by monitoring the communication of actors. It was also able to cut the list into 6 similarly sized segments (5 V-shaped and an I-shaped at the end of the list (bottom)). This solution minimizes the communication between schedulers.","category":"page"},{"location":"showcase/","page":"Showcase","title":"Showcase","text":"The source code of the sample is at examples/linkedlist.jl.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Requirements","page":"Installation","title":"Requirements","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Linux or OSX \nJulia >= v\"1.4\" download\ngit (Tested with \"version 2.17.1\") download\nNode.js (Tested with \"v12.4.0\") download - For the optional frontend","category":"page"},{"location":"install/#Install-and-run-a-sample","page":"Installation","title":"Install & run a sample","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"You need to checkout two repos: The Circo \"backend\" and the CircoCore.js \"frontend\".","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"In terminal #1 (backend)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"git clone https://github.com/Circo-dev/Circo.git\ncd Circo/\njulia --project -e 'using Pkg;Pkg.instantiate()'\nbin/circonode.sh --threads 6 --zygote","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This starts a local (in-process) cluster with six schedulers running the sample project.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"In terminal #2 (monitoring frontend, optional)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"git clone https://github.com/Circo-dev/CircoCore.js.git\ncd CircoCore.js\nnpm install\nnpm run serve","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This starts a web server on port 8000. Open http://localhost:8000","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"info: Note\nItems from CircoCore are reexported thus available directly from Circo.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CircoCore]","category":"page"},{"location":"reference/#CircoCore.AbstractActor","page":"Reference","title":"CircoCore.AbstractActor","text":"abstract type AbstractActor{TCoreState}\n\nSupertype of all actors.\n\nSubtypes must be mutable and must provide a field core::TCoreState that can remain undefined after creation.\n\nExamples\n\nmutable struct DataHolder{TValue, TCore} <: AbstractActor{TCore}\n    value::TValue\n    core::TCore\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.ActorId","page":"Reference","title":"CircoCore.ActorId","text":"ActorId\n\nA cluster-unique id that is randomly generated when the actor is spawned (first scheduled).\n\nActorId is an alias to UInt64 at the time, so it may pop up in error messages as such.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.Addr","page":"Reference","title":"CircoCore.Addr","text":"Addr(postcode::PostCode, box::ActorId)\nAddr(readable_address::String)\nAddr()\n\nThe full address of an actor.\n\nWhen created without arguments, it will be the null address. See isnulladdr()\n\nIf the referenced actor migrates to a different scheduler, messages sent to the old address will bounce back as RecipientMoved and the Addr must be updated manually.\n\nExamples\n\nAddr(\"192.168.1.11:24721\", 0xbc6ac81fc7e4ea2)\n\nAddr(\"192.168.1.11:24721/bc6ac81fc7e4ea2\")\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.CircoContext","page":"Reference","title":"CircoCore.CircoContext","text":"CircoContext(;options...) <: AbstractContext\n\nStore configuration, manage staging and run-time code optimizations for Circo.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.Infoton","page":"Reference","title":"CircoCore.Infoton","text":"Infoton(sourcepos::Pos, energy::Real = 1)\n\nCreate an Infoton that carries abs(energy) amount of energy and has the sign sign(energy).\n\nThe infoton mediates the force that awakens between communicating actors. When arriving at its target actor, the infoton pulls/pushes the actor toward/away from its source, depending on its sign (positive pulls).\n\nThe exact details of how the Infoton should act at its target is actively researched. Please check or overload apply_infoton.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.NameQuery","page":"Reference","title":"CircoCore.NameQuery","text":"NameQuery(name::String) <: Request\n\nA query that can be sent to a remote scheduler for querying its local registry.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.Pos","page":"Reference","title":"CircoCore.Pos","text":"Pos(x::Real, y::Real, z::Real)\nPos(coords)\n\nA point in the 3D \"actor space\".\n\nYou can access the coords by pos.x, pos.y, pos.z.\n\nPos is implemented using an SVector{3, Float32}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.PostCode","page":"Reference","title":"CircoCore.PostCode","text":"PostCode\n\nA string that identifies a scheduler.\n\nExamples\n\n\"192.168.1.11:24721\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#CircoCore.addr-Tuple{AbstractActor}","page":"Reference","title":"CircoCore.addr","text":"addr(a::AbstractActor)\n\nReturn the address of the actor.\n\nCall this on a spawned actor to get its address. Throws UndefRefError if the actor is not spawned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.apply_infoton-Tuple{AbstractActor,Infoton}","page":"Reference","title":"CircoCore.apply_infoton","text":"apply_infoton(targetactor::AbstractActor, infoton::Infoton)\n\nAn infoton acting on an actor.\n\nPlease check the source and the examples for more info.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.box-Tuple{AbstractActor}","page":"Reference","title":"CircoCore.box","text":"box(a::AbstractActor)\n\nReturn the 'P.O. box' of the spawned actor.\n\nCall this on a spawned actor to get its id (aka box). Throws UndefRefError if the actor is not spawned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.box-Tuple{Addr}","page":"Reference","title":"CircoCore.box","text":"box(a::Addr)::ActorId\n\nReturn the box of the address, that is the id of the actor.\n\nWhen the actor migrates, its box remains the same, only the PostCode of the address changes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.die-Tuple{ActorService,AbstractActor}","page":"Reference","title":"CircoCore.die","text":"die(service, me::AbstractActor)\n\nUnschedule the actor from its current scheduler.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.getname-Tuple{Any,String}","page":"Reference","title":"CircoCore.getname","text":"function getname(service, name::String)::Union{Addr, Nothing}\n\nReturn the registered name from the scheduler-local registry, or nothing.\n\nSee also: NameQuery\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.isbaseaddress-Tuple{Addr}","page":"Reference","title":"CircoCore.isbaseaddress","text":"isbaseaddress(addr::Addr)::Bool\n\nReturn true if addr is a base address, meaning it references a scheduler directly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.isnulladdr-Tuple{Addr}","page":"Reference","title":"CircoCore.isnulladdr","text":"isnulladdr(a::Addr)\n\nCheck if the given address is a null address, meaning that it points to \"nowhere\", messages sent to it will be dropped.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.onmessage-Tuple{AbstractActor,Any,Any}","page":"Reference","title":"CircoCore.onmessage","text":"onmessage(me::AbstractActor, message, service)\n\nHandle a message arriving at an actor.\n\nOnly the payload of the message is delivered, there is currently no way to access the infoton or the sender address. If you need a reply, include the sender address in the request.\n\nNote: Do not forget to import it or use its qualified name to allow overloading!\n\nExamples\n\nimport CircoCore.onmessage\n\nstruct TestRequest\n    replyto::Addr\nend\n\nstruct TestResponse end\n\nfunction onmessage(me::MyActor, message::TestRequest, service)\n    send(service, me, message.replyto, TestResponse())\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.onmigrate-Tuple{AbstractActor,Any}","page":"Reference","title":"CircoCore.onmigrate","text":"onmigrate(me::AbstractActor, service)\n\nLifecycle callback that marks a successful migration.\n\nIt is called on the target scheduler, before any messages will be delivered.\n\nNote: Do not forget to import it or use its qualified name to allow overloading!\n\nExamples\n\nimport CircoCore.onmigrate\n\nfunction onmigrate(me::MyActor, service)\n    @info \"Successfully migrated, registering a name on the new scheduler\"\n    registername(service, \"MyActor\", me)\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.onschedule-Tuple{AbstractActor,Any}","page":"Reference","title":"CircoCore.onschedule","text":"CircoCore.onschedule(me::AbstractActor, service)\n\nLifecycle callback that marks the first scheduling of the actor, called during spawning, before any onmessage.\n\nNote: Do not forget to import it or use its qualified name to allow overloading!\n\nExamples\n\nimport CircoCore.onschedule\n\nfuntion onschedule(me::MyActor, service)\n    registername(service, \"MyActor\", me) # Register this actor in the local name service\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.pos-Tuple{AbstractActor}","page":"Reference","title":"CircoCore.pos","text":"pos(a::AbstractActor)::Pos\n\nreturn the current position of the actor.\n\nCall this on a spawned actor to get its position. Throws UndefRefError if the actor is not spawned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.redirect-Tuple{Addr,String}","page":"Reference","title":"CircoCore.redirect","text":"redirect(addr::Addr, topostcode::PostCode):Addr\n\nCreate a new Addr by replacing the postcode of the given one.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.registername-Tuple{Any,String,AbstractActor}","page":"Reference","title":"CircoCore.registername","text":"registername(service, name::String, actor::AbstractActor)\n\nRegister the given actor under the given name in the scheduler-local name registry.\n\nNote that there is no need to unregister the name when migrating or dying\n\nTODO implement manual and auto-unregistration\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.send-Union{Tuple{TCore}, Tuple{TMsg}, Tuple{TScheduler}, Tuple{ActorService{TScheduler,TMsg,TCore},AbstractActor,Addr,Any}, Tuple{ActorService{TScheduler,TMsg,TCore},AbstractActor,Addr,Any,Real}} where TCore where TMsg where TScheduler","page":"Reference","title":"CircoCore.send","text":"send(service, sender::AbstractActor, to::Addr, messagebody::Any, energy::Real = 1; timeout::Real = 2.0)\n\nSend a message from an actor to an another.\n\nPart of the actor API, can be called from a lifecycle callback, providing the service you got.\n\nmessagebody can be of any type, but a current limitation of inter-node communication is that the serialized form of messagebody must fit in an IPv4 UDP packet with ~100 bytes margin. The exact value depends on the MTU size of the network and changing implementation details, but 1380 bytes can be considered safe. You may be able to tune your system to get higher values.\n\nIf messagebody is a Request, a timeout will be set for the token of it. The timeout keyword argument can be used to control the deadline (seconds).\n\nenergy sets the energy and sign of the Infoton attached to the message.\n\nExamples\n\nconst QUERY = \"The Ultimate Question of Life, The Universe, and Everything.\"\n\nmutable struct MyActor <: AbstractActor{TCoreState}\n    searcher::Addr\n    core::CoreState\n    MyActor() = new()\nend\n\nstruct Start end\n\nstruct Search\n    query::String\nend\n\n[...] # Spawn the searcher or receive its address\n\n\nfunction CircoCore.onmessage(me::MyActor, message::Start, service)\n    send(service,\n            me,\n            me.searcher,\n            Search(QUERY, addr(me)))\nend\n\nImplementation\n\nPlease note that service is always the last argument of lifecycle callbacks like onmessage. It's because onmessage is dynamically dispatched, and service provides no information about where to dispatch. (Only one service instance exists as of v\"0.2.0\") Listing it at the end improves the performance.\n\nOn the other hand, actor API endpoints like send are always statically dispatched, thus they can accept the service as their first argument, allowing the user to treat e.g. \"spawn(service\" as a single unit of thought and not forget to write out the meaningless service.\n\nConsistency is just as important as convenience. But performance is king.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CircoCore.spawn-Tuple{ActorService,AbstractActor}","page":"Reference","title":"CircoCore.spawn","text":"spawn(service, actor::AbstractActor, [pos::Pos])::Addr\n\nSpawn the given actor on the scheduler represented by service, return the address of it.\n\nPart of the actor API, can be called from a lifecycle callback, providing the service you got.\n\nThe onschedule callback of actor will run before this function returns.\n\nExamples\n\nTODO: update this sample\n\nmutable struct ListItem{TData, TCore} <: AbstractActor{TCore}\n    data::TData\n    next::Union{Nothing, Addr}\n    core::TCore\n    ListItem(data, core) = new{typeof(data), typeof(core)}(data, nothing, core)\nend\n\nstruct Append{TData}\n    value::TData\nend\n\nfunction CircoCore.onmessage(me::ListItem, message::Append, service)\n    me.next = spawn(service, ListItem(message.value))\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Circo]","category":"page"},{"location":"reference/#Circo.RecipientMoved","page":"Reference","title":"Circo.RecipientMoved","text":"RecipientMoved{TBody}\n\nIf a message is undeliverable because the tartget actor moved to a known lcoation, this message will be sent back to the sender. The original message will not be delivered, but it gets included in the RecipientMoved message.\n\nstruct RecipientMoved{TBody}\n    oldaddress::Addr\n    newaddress::Addr\n    originalmessage::TBody\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#Circo.Throw","page":"Reference","title":"Circo.Throw","text":"Throw\n\nMessage that throws an error from the monitoring actor\n\n\n\n\n\n","category":"type"},{"location":"reference/#Circo.migrate-Tuple{ActorService,AbstractActor,String}","page":"Reference","title":"Circo.migrate","text":"migrate(service, actor::AbstractActor, topostcode::PostCode)\n\n\n\n\n\n","category":"method"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Circo is in alpha stage. Several stability issues are known. Please file an issue if you cannot find the workaround here!","category":"page"},{"location":"troubleshooting/#The-frontend-fails-to-display-the-correct-number-of-schedulers","page":"Troubleshooting","title":"The frontend fails to display the correct number of schedulers","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Open the JavaScript console (F12) and reload the page. You should see exactly one connection error message, and for every scheduler a log about \"actor registration\". If not, then you may need to restart your browser. It may also be possible that orphaned Circo schedulers are running.","category":"page"},{"location":"troubleshooting/#Sometimes-the-backend-crashes-when-the-browser-disconnects","page":"Troubleshooting","title":"Sometimes the backend crashes when the browser disconnects","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This seems like a bug in HTTP.jl or in Julia itself, partially workarounded, so happens rarely. Work on fixing this hasn't yet started, the only known workaround at the time is not closing the browser and not reloading the page while connected to the backend. Note that using the monitoring frontend is optional.","category":"page"},{"location":"troubleshooting/#The-cluster-does-not-handle-node-removal","page":"Troubleshooting","title":"The cluster does not handle node removal","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Not yet implemented, and no workaround is available, but seems like relatively straightforward to fix.","category":"page"},{"location":"#Introducing-Circo","page":"Introducing Circo","title":"Introducing Circo","text":"","category":"section"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"Circo is a fast, scalable and extensible actor system.","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"Fast: Up to 630 million msg/sec on a single node [singlenode]. Up to 20 million msg/sec single threaded performance.\nScalable: Includes a decentralized cluster manager to avoid single point of failure.\nExtensible: Build on top of a custom-made plugin system which allows inlining of plugin code into the main event loop. Multithreading is a plugin. Actor migration is a plugin. Even last-mile message delivery is a plugin. If something is not a plugin, that's a bug.","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"Circo also features Infoton Optimization, a physics-inspired solution to the data-locality problem. [infoton]","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"Circo is implemented in Julia - an incredibly fast, dynamic, yet compiled language -, and it has a JavaScript sister: CircoCore.js, which can run in the browser and transparently integrate into the Circo cluster. These two components form a high performance, distributed application platform.","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"There is a monitoring tool named \"Camera Diserta\" which can help to tune Circo applications and to research Infoton Optimization.","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"Please note that Circo is in alpha stage. It is more like a research tool at the time than a mature platform. The documentation is also far from complete. Contributions are welcome!","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"[singlenode]: Measured on an AWS C6g 16xlarge instance, 64 Graviton2 Arm core. See maxthroughput.jl","category":"page"},{"location":"","page":"Introducing Circo","title":"Introducing Circo","text":"[infoton]: Go to Infoton Optimization for a description of this novel algorithm.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EditURL = \"https://github.com/Circo-dev/Circo/blob/master/docs/src/tutorial.jl\"","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will create a distributed engine for Twitter clones. Don't worry, it is not complicated, at least not in this unfinished prototype form. But it works, and it scales to any size!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For simplicity, we store posts in simple structs (inside actors, but not actors themselves):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Circo\n\nstruct Post\n    authorname::String\n    text::String\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A Feed, our first actor contains a growing list of posts from different authors. Our simplistic approach is that when someone opens the twitter clone, a new Feed will be created for that session, populated with recent posts. While the feed is alive, it also receives pushed updates from its sources.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mutable struct Feed <: AbstractActor{Any}\n    posts::Vector{Post}\n    sources::Vector{Addr} # Post sources that this feed watches\n    core::Any # This small boilerplate is needed for every actor\n    Feed() = new([], [])\n    Feed(sources) = new(sources, [])\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When the feed receives a Post, it just prints and stores it:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function Circo.onmessage(me::Feed, post::Post, service)\n    println(\"Feed $(box(me)) received post: $post\")\n    push!(me.posts, post)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can try out what we have:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"feed = Feed()\n\nctx = CircoContext() # This is our connection to the Circo system\ns = ActorScheduler(ctx, [feed])\n@async s() # Start the scheduler in the background\n\nsend(s, feed, Post(\"Me\", \"My first post\")) # Send a post from the outside to the feed\nfeed.posts","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Great, the post arrived at the feed!","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we will create a Profile actor which can create posts and follow other profiles.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mutable struct Profile <: AbstractActor{Any}\n    name::String\n    posts::Vector{Post}\n    following::Vector{Addr} # Adresses of the profiles we follow\n    watchers::Vector{Addr} # Feeds to notify about our new posts\n    core::Any\n    Profile(name) = new(name, [], [], [])\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Profile will start following another one if it receives the Follow message:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct Follow\n    whom::Addr\nend\n\nfunction Circo.onmessage(me::Profile, msg::Follow, service)\n    println(\"$(me.name) ($(box(me))): Starting to follow $(box(msg.whom))\")\n    push!(me.following, msg.whom)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now we can create a few profiles and connect them:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"alice = spawn(s, Profile(\"Alice\"))\nbela = spawn(s, Profile(\"Béla\"))\ncecile = spawn(s, Profile(\"Cécile\"))\nsend(s, alice, Follow(bela))\nsend(s, alice, Follow(cecile))\nsend(s, bela, Follow(cecile))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Profiles will create posts when they receive a CreatePost message:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct CreatePost\n    text::String\nend\n\nfunction Circo.onmessage(me::Profile, msg::CreatePost, service)\n    post = Post(me.name, msg.text)\n    println(\"Posting: $post\")\n    push!(me.posts, post)\n    notify_watchers(me, post, service) # Send out the post to the feeds of our live followers (if any)\nend\n\nfunction notify_watchers(me::Profile, post, service)\n    for watcher in me.watchers\n        send(service, me, watcher, post)\n    end\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let our users create a few interesting posts:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"send(s, alice, CreatePost(\"Through the Looking-Glass\"))\nsend(s, bela, CreatePost(\"I lost my handkerchief\"))\nsend(s, cecile, CreatePost(\"My first post\"))\nsend(s, cecile, CreatePost(\"At the zoo\"))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As there are no feed watching any of the profiles at the time, no notifications were sent out.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Time to create a live feed! The CreateFeed message asks a profile to create a feed that is sourced from the profiles this one follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct CreateFeed end\nfunction Circo.onmessage(me::Profile, msg::CreateFeed, service)\n    feed = spawn(service, Feed(copy(me.following)))\n    println(\"Created Feed: $(feed)\")\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When the feed is spawned, it starts watching the profiles by sending them an AddWatcher message.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"struct AddWatcher\n    watcher::Addr\nend\n\nfunction Circo.onschedule(me::Feed, service)\n    for source in me.sources\n        send(service, me, source, AddWatcher(addr(me)))\n    end\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The profile reacts with immediately sending back its last 3 posts, and starting to send notifications about future posts:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function Circo.onmessage(me::Profile, msg::AddWatcher, service)\n    for post in me.posts[max(end - 2, 1):end]\n        send(service, me, msg.watcher, post)\n    end\n    push!(me.watchers, msg.watcher)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At the end we can simulate the event that Alice opens the app like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"send(s, alice, CreateFeed())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"When Béla creates a new post, it will arrive on the feed of Alice:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sleep(2.0)\nsend(s, bela, CreatePost(\"Have you ever seen a llama wearing pajamas?\"))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"X","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This page was generated using Literate.jl.","category":"page"}]
}
